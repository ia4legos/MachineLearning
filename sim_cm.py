# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ouWdD_hfb8hSlpNdJSdN2vI-KHk5Uwye
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np          # importamos numpy como np
import pandas as pd         # importamos pandas como pd
import math
import random
import warnings
# Ignorar advertencias de convergencia para los modelos lineales
warnings.filterwarnings('ignore', category=UserWarning, module='sklearn')

# Cargamos módulos de análisis gráficos
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
sns.set_theme(style = 'whitegrid')
# %config InlineBackend.figure_format = 'retina'


# Función para la rerpesentación gráfica de la función de probabildiad y de distribución de una variable aleatoria discreta

def graficar_discreta(x, fx):
  """
  Función para representar gráficamente la función de masa de probabilidad y la función de distribución de una variable discreta.

  Args:
    x: valores de la variable discreta
    fx: función de masa de probabilidad para cada valor de x

  Returns:
    Gráficos de la función de masa de probabilidad y la función de distribución.
  """
  # posiciones en el gráfico de los valores d ela variable discreta
  pos = np.arange(len(x))
  # Función de distribución
  fdist = [sum(fx[:(l+1)]) for l in range(len(fx))]

  # Entorno gráfico
  fig, ax = plt.subplots(1, 2, figsize=(7, 4))
  # Pintamos los puntos con x y la función de masa de probabilidad
  ax[0].plot(pos, fx, 'bo');
  # Dibujamos las líneas verticales correspondientes con sus caractarísticas
  ax[0].vlines(pos, 0, fx, colors='b', lw=5, alpha=0.5);
  # Ponemos un título
  ax[0].set_title('Función de masa de probabilidad')
  # Ponemos etiquetas a los ejes x e y
  ax[0].set_xticks(pos, labels=x)
  ax[0].set_ylabel('Probabilidad')
  ax[0].set_xlabel('Espacio muestral')

  #### Función de distribución
  # Pintamos los puntos con x y la función de distribución
  ax[1].plot(pos, fdist, 'bo');
  # Dibujamos las líneas verticales correspondientes con sus caractarísticas
  ax[1].vlines(pos, 0, fdist, colors='b', lw=5, alpha=0.5);
  # Ponemos un título
  ax[1].set_title('Función de distribución')
  # Ponemos etiquetas a los ejes x e y
  ax[1].set_xticks(pos, labels=x)
  ax[1].set_ylabel('Probabilidad')
  ax[1].set_xlabel('Espacio muestral')
  plt.tight_layout()

# Función para obtener un dataframe con la función de masa de probabilidad y la función de distribución de una variable discreta.
def distr_discreta(x, fx):
  """
  Función para obtener un dataframe con la función de masa de probabilidad y la función de distribución de una variable discreta.

  Args:
    x: valores de la varaible discreta
    fx: función de masa de probabilidad

  Returns:
    pdDataFrame con los valores de la variable, la función de masa de probabilidad y la función de distribución.
  """
  # posiciones en el gráfico de los valores d ela variable discreta
  pos = np.arange(len(x))
  # Función de distribución
  fdist = [sum(fx[:(l+1)]) for l in range(len(fx))]
  return(pd.DataFrame({"x": x, "fmp":fx, "fdist":fdist}))

# Función para obtener el estimador Monte Carlo de h(x) y un intervalo de confianza al 95%
def MC_estim(sims):
  """
  Función para obtener el estimador Monte Carlo de h(x) y un intervalo de confianza al 95%

  Args:
   sims: Si queremos un estimador de h(x) pasamos directamente als simulaciones,
          mientras que si deseamos una probabildiad debemos pasar el vector 1-0
          que cumple con las condiciones de la probabilidad buscada

  Returns: 
    Devuelve el estimador e intervalo de confianza por Monte Carlo
  """
  from scipy.stats import norm

  # Número de simulaciones cargadas
  size = len(sims)
  # Estimador MC
  estim = sims.mean()
  # Estimador MC del IC
  error = math.sqrt(sims.var())*math.sqrt(size-1)/size
  cuantil = norm.ppf(1-0.05/2)
  ic_low = estim - cuantil*error
  ic_up = estim + cuantil*error
  # Resultado
  return([round(estim,4), round(ic_low,4), round(ic_up,4)])

def generate_poisson_events(rate, time_duration, seed):
  """
  La función generate_poisson_events simula un proceso de Poisson mediante la generación de eventos
  con una tasa promedio dada (rate) durante un período de tiempo especificado (time_duration).

  La función devuelve el número de eventos (num_events), los tiempos de los eventos (event_times) y
  los tiempos entre llegadas correspondientes (inter_arrival_times), lo que proporciona una
  representación de un proceso de Poisson.
  """
  random.seed(seed)
  num_events = np.random.poisson(rate * time_duration)
  event_times = np.sort(np.random.uniform(0, time_duration, num_events))
  inter_arrival_times = np.diff(event_times)
  return num_events, event_times, inter_arrival_times


def plot_non_sequential_poisson(num_events, event_times, inter_arrival_times, rate, time_duration):
  """
  La función plot_non_sequential_poisson crea una visualización de dos paneles de
  una simulación de proceso de Poisson no secuencial. El primer panel muestra los tiempos de los eventos
  y el segundo muestra un histograma de los tiempos entre llegadas entre eventos.

  La función acepta la cantidad de eventos (num_events), los tiempos de los eventos (event_times),
  los tiempos entre llegadas (inter_arrival_times), la tasa (rate) del proceso de Poisson y
  la duración total de la simulación como entrada (time_duration).
  """
  fig, axs = plt.subplots(1, 2, figsize=(15, 6))
  fig.suptitle(f'Poisson Process Simulation (λ = {rate}, Duration = {time_duration} seconds)\n', fontsize=16)

  axs[0].step(event_times, np.arange(1, num_events + 1), where='post', color='blue')
  axs[0].set_xlabel('Time')
  axs[0].set_ylabel('Event Number')
  axs[0].set_title(f'Poisson Process Event Times\nTotal: {num_events} events\n')
  axs[0].grid(True)

  axs[1].hist(inter_arrival_times, bins=20, color='green', alpha=0.5)
  axs[1].set_xlabel('Inter-Arrival Time')
  axs[1].set_ylabel('Frequency')
  axs[1].set_title(f'Histogram of Inter-Arrival Times\nMEAN: {np.mean(inter_arrival_times):.2f} | STD: {np.std(inter_arrival_times):.2f}\n')
  axs[1].grid(True, alpha=0.5)

  plt.tight_layout()
  plt.show()


def plot_sequential_poisson(num_events_list, event_times_list, inter_arrival_times_list, rate, time_duration):
  """
  La función plot_sequential_poisson es responsable de generar un gráfico secuencial de eventos de procesos de Poisson
  simulados con diferentes tasas de llegada. Crea una figura de subgráfico de 2x1 que muestra los tiempos de los eventos
  y un histograma de los tiempos entre llegadas. Cada subgráfico muestra datos para múltiples procesos de Poisson
  con diferentes tasas, que se distinguen por colores distintos. La función toma num_events_list, event_times_list
  e inter_arrival_times_list como entrada, que contienen estadísticas de eventos para cada tasa, junto con la lista de
  tasas que especifica los valores lambda y time_duration que indica la duración de la simulación.

  Visualiza los datos, mostrando la ocurrencia de eventos a lo largo del tiempo y la distribución de los tiempos
  entre llegadas, lo que ayuda a comparar y analizar procesos de Poisson con diferentes tasas de llegada en un solo gráfico.
  """
  fig, axs = plt.subplots(1, 2, figsize=(15, 6))
  fig.suptitle(f'Poisson Process Simulation (Duration = {time_duration} seconds)\n', fontsize=16)

  axs[0].set_xlabel('Time')
  axs[0].set_ylabel('Event Number')
  axs[0].set_title(f'Poisson Process Event Times')
  axs[0].grid(True)

  axs[1].set_xlabel('Inter-Arrival Time')
  axs[1].set_ylabel('Frequency')
  axs[1].set_title(f'Histogram of Inter-Arrival Times')
  axs[1].grid(True, alpha=0.5)

  color_palette = plt.get_cmap('tab20')
  colors = [color_palette(i) for i in range(len(rate))]

  for n, individual_rate in enumerate(rate):
      num_events = num_events_list[n]
      event_times = event_times_list[n]
      inter_arrival_times = inter_arrival_times_list[n]

      axs[0].step(event_times, np.arange(1, num_events + 1), where='post', color=colors[n], label=f'λ = {individual_rate}, Total Events: {num_events}')
      axs[1].hist(inter_arrival_times, bins=20, color=colors[n], alpha=0.5, label=f'λ = {individual_rate}, MEAN: {np.mean(inter_arrival_times):.2f}, STD: {np.std(inter_arrival_times):.2f}')

  axs[0].legend()
  axs[1].legend()

  plt.tight_layout()
  plt.show()


def poisson_simulation(rate, time_duration, show_visualization=True, seed):
    """
    La función poisson_simulation simula un proceso de Poisson con una sola tasa o una lista de tasas
    durante un período de tiempo especificado. Si se proporciona una sola tasa, genera eventos de Poisson
    y sus tiempos entre llegadas y, opcionalmente, los visualiza. Si se proporciona una lista de tasas,
    genera eventos de Poisson y tiempos entre llegadas para cada tasa y, opcionalmente, los visualiza
    de forma secuencial (show_visualization = True).

    La función devuelve las estadísticas de eventos número de eventos (num_events_list), tiempos de
    eventos (event_times_list), tiempos entre llegadas (inter_arrival_times_list) cuando la visualización
    está desactivada o None cuando la visualización está habilitada.
    """
    random.seed(seed)
    
    if isinstance(rate, int):
        num_events, event_times, inter_arrival_times = generate_poisson_events(rate, time_duration)

        if show_visualization:
            plot_non_sequential_poisson(num_events, event_times, inter_arrival_times, rate, time_duration)
        else:
            return num_events, event_times, inter_arrival_times

    elif isinstance(rate, list):
        num_events_list = []
        event_times_list = []
        inter_arrival_times_list = []

        for individual_rate in rate:
            num_events, event_times, inter_arrival_times = generate_poisson_events(individual_rate, time_duration)
            num_events_list.append(num_events)
            event_times_list.append(event_times)
            inter_arrival_times_list.append(inter_arrival_times)

        if show_visualization:
            plot_sequential_poisson(num_events_list, event_times_list, inter_arrival_times_list, rate, time_duration)
        else:
            return num_events_list, event_times_list, inter_arrival_times_list
