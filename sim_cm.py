# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ouWdD_hfb8hSlpNdJSdN2vI-KHk5Uwye
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np          # importamos numpy como np
import pandas as pd         # importamos pandas como pd
import math
import random
import warnings
# Ignorar advertencias de convergencia para los modelos lineales
warnings.filterwarnings('ignore', category=UserWarning, module='sklearn')

# Cargamos módulos de análisis gráficos
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
sns.set_theme(style = 'whitegrid')
# %config InlineBackend.figure_format = 'retina'


# Función para la rerpesentación gráfica de la función de probabildiad y de distribución de una variable aleatoria discreta

def graficar_discreta(x, fx):
  """
  Función para representar gráficamente la función de masa de probabilidad y la función de distribución de una variable discreta.

  Args:
    x: valores de la variable discreta
    fx: función de masa de probabilidad para cada valor de x

  Returns:
    Gráficos de la función de masa de probabilidad y la función de distribución.
  """
  # posiciones en el gráfico de los valores d ela variable discreta
  pos = np.arange(len(x))
  # Función de distribución
  fdist = [sum(fx[:(l+1)]) for l in range(len(fx))]

  # Entorno gráfico
  fig, ax = plt.subplots(1, 2, figsize=(7, 4))
  # Pintamos los puntos con x y la función de masa de probabilidad
  ax[0].plot(pos, fx, 'bo');
  # Dibujamos las líneas verticales correspondientes con sus caractarísticas
  ax[0].vlines(pos, 0, fx, colors='b', lw=5, alpha=0.5);
  # Ponemos un título
  ax[0].set_title('Función de masa de probabilidad')
  # Ponemos etiquetas a los ejes x e y
  ax[0].set_xticks(pos, labels=x)
  ax[0].set_ylabel('Probabilidad')
  ax[0].set_xlabel('Espacio muestral')

  #### Función de distribución
  # Pintamos los puntos con x y la función de distribución
  ax[1].plot(pos, fdist, 'bo');
  # Dibujamos las líneas verticales correspondientes con sus caractarísticas
  ax[1].vlines(pos, 0, fdist, colors='b', lw=5, alpha=0.5);
  # Ponemos un título
  ax[1].set_title('Función de distribución')
  # Ponemos etiquetas a los ejes x e y
  ax[1].set_xticks(pos, labels=x)
  ax[1].set_ylabel('Probabilidad')
  ax[1].set_xlabel('Espacio muestral')
  plt.tight_layout()

# Función para obtener un dataframe con la función de masa de probabilidad y la función de distribución de una variable discreta.
def distr_discreta(x, fx):
  """
  Función para obtener un dataframe con la función de masa de probabilidad y la función de distribución de una variable discreta.

  Args:
    x: valores de la varaible discreta
    fx: función de masa de probabilidad

  Returns:
    pdDataFrame con los valores de la variable, la función de masa de probabilidad y la función de distribución.
  """
  # posiciones en el gráfico de los valores d ela variable discreta
  pos = np.arange(len(x))
  # Función de distribución
  fdist = [sum(fx[:(l+1)]) for l in range(len(fx))]
  return(pd.DataFrame({"x": x, "fmp":fx, "fdist":fdist}))

# Función para obtener el estimador Monte Carlo de h(x) y un intervalo de confianza al 95%
def MC_estim(sims):
  """
  Función para obtener el estimador Monte Carlo de h(x) y un intervalo de confianza al 95%

  Args:
   sims: Si queremos un estimador de h(x) pasamos directamente als simulaciones,
          mientras que si deseamos una probabildiad debemos pasar el vector 1-0
          que cumple con las condiciones de la probabilidad buscada

  Returns: 
    Devuelve el estimador e intervalo de confianza por Monte Carlo
  """
  from scipy.stats import norm

  # Número de simulaciones cargadas
  size = len(sims)
  # Estimador MC
  estim = sims.mean()
  # Estimador MC del IC
  error = math.sqrt(sims.var())*math.sqrt(size-1)/size
  cuantil = norm.ppf(1-0.05/2)
  ic_low = estim - cuantil*error
  ic_up = estim + cuantil*error
  # Resultado
  return([round(estim,4), round(ic_low,4), round(ic_up,4)])

def generate_poisson_events(rate, time_duration):
  """
  La función generate_poisson_events simula un proceso de Poisson mediante la generación de eventos
  con una tasa promedio dada (rate) durante un período de tiempo especificado (time_duration).

  La función devuelve el número de eventos (num_events), los tiempos de los eventos (event_times) y
  los tiempos entre llegadas correspondientes (inter_arrival_times), lo que proporciona una
  representación de un proceso de Poisson.
  """
  num_events = np.random.poisson(rate * time_duration)
  event_times = np.sort(np.random.uniform(0, time_duration, num_events))
  inter_arrival_times = np.diff(event_times)
  return num_events, event_times, inter_arrival_times


def plot_non_sequential_poisson(num_events, event_times, inter_arrival_times, rate, time_duration):
  """
  La función plot_non_sequential_poisson crea una visualización de dos paneles de
  una simulación de proceso de Poisson no secuencial. El primer panel muestra los tiempos de los eventos
  y el segundo muestra un histograma de los tiempos entre llegadas entre eventos.

  La función acepta la cantidad de eventos (num_events), los tiempos de los eventos (event_times),
  los tiempos entre llegadas (inter_arrival_times), la tasa (rate) del proceso de Poisson y
  la duración total de la simulación como entrada (time_duration).
  """
  fig, axs = plt.subplots(1, 2, figsize=(15, 6))
  fig.suptitle(f'Poisson Process Simulation (λ = {rate}, Duration = {time_duration} seconds)\n', fontsize=16)

  axs[0].step(event_times, np.arange(1, num_events + 1), where='post', color='blue')
  axs[0].set_xlabel('Time')
  axs[0].set_ylabel('Event Number')
  axs[0].set_title(f'Poisson Process Event Times\nTotal: {num_events} events\n')
  axs[0].grid(True)

  axs[1].hist(inter_arrival_times, bins=20, color='green', alpha=0.5)
  axs[1].set_xlabel('Inter-Arrival Time')
  axs[1].set_ylabel('Frequency')
  axs[1].set_title(f'Histogram of Inter-Arrival Times\nMEAN: {np.mean(inter_arrival_times):.2f} | STD: {np.std(inter_arrival_times):.2f}\n')
  axs[1].grid(True, alpha=0.5)

  plt.tight_layout()
  plt.show()


def plot_sequential_poisson(num_events_list, event_times_list, inter_arrival_times_list, rate, time_duration):
  """
  La función plot_sequential_poisson es responsable de generar un gráfico secuencial de eventos de procesos de Poisson
  simulados con diferentes tasas de llegada. Crea una figura de subgráfico de 2x1 que muestra los tiempos de los eventos
  y un histograma de los tiempos entre llegadas. Cada subgráfico muestra datos para múltiples procesos de Poisson
  con diferentes tasas, que se distinguen por colores distintos. La función toma num_events_list, event_times_list
  e inter_arrival_times_list como entrada, que contienen estadísticas de eventos para cada tasa, junto con la lista de
  tasas que especifica los valores lambda y time_duration que indica la duración de la simulación.

  Visualiza los datos, mostrando la ocurrencia de eventos a lo largo del tiempo y la distribución de los tiempos
  entre llegadas, lo que ayuda a comparar y analizar procesos de Poisson con diferentes tasas de llegada en un solo gráfico.
  """
  fig, axs = plt.subplots(1, 2, figsize=(15, 6))
  fig.suptitle(f'Poisson Process Simulation (Duration = {time_duration} seconds)\n', fontsize=16)

  axs[0].set_xlabel('Time')
  axs[0].set_ylabel('Event Number')
  axs[0].set_title(f'Poisson Process Event Times')
  axs[0].grid(True)

  axs[1].set_xlabel('Inter-Arrival Time')
  axs[1].set_ylabel('Frequency')
  axs[1].set_title(f'Histogram of Inter-Arrival Times')
  axs[1].grid(True, alpha=0.5)

  color_palette = plt.get_cmap('tab20')
  colors = [color_palette(i) for i in range(len(rate))]

  for n, individual_rate in enumerate(rate):
      num_events = num_events_list[n]
      event_times = event_times_list[n]
      inter_arrival_times = inter_arrival_times_list[n]

      axs[0].step(event_times, np.arange(1, num_events + 1), where='post', color=colors[n], label=f'λ = {individual_rate}, Total Events: {num_events}')
      axs[1].hist(inter_arrival_times, bins=20, color=colors[n], alpha=0.5, label=f'λ = {individual_rate}, MEAN: {np.mean(inter_arrival_times):.2f}, STD: {np.std(inter_arrival_times):.2f}')

  axs[0].legend()
  axs[1].legend()

  plt.tight_layout()
  plt.show()


def poisson_simulation(rate, time_duration, show_visualization=True):
    """
    La función poisson_simulation simula un proceso de Poisson con una sola tasa o una lista de tasas
    durante un período de tiempo especificado. Si se proporciona una sola tasa, genera eventos de Poisson
    y sus tiempos entre llegadas y, opcionalmente, los visualiza. Si se proporciona una lista de tasas,
    genera eventos de Poisson y tiempos entre llegadas para cada tasa y, opcionalmente, los visualiza
    de forma secuencial (show_visualization = True).

    La función devuelve las estadísticas de eventos número de eventos (num_events_list), tiempos de
    eventos (event_times_list), tiempos entre llegadas (inter_arrival_times_list) cuando la visualización
    está desactivada o None cuando la visualización está habilitada.
    """
       
    if isinstance(rate, int):
        num_events, event_times, inter_arrival_times = generate_poisson_events(rate, time_duration)

        if show_visualization:
            plot_non_sequential_poisson(num_events, event_times, inter_arrival_times, rate, time_duration)
        else:
            return num_events, event_times, inter_arrival_times

    elif isinstance(rate, list):
        num_events_list = []
        event_times_list = []
        inter_arrival_times_list = []

        for individual_rate in rate:
            num_events, event_times, inter_arrival_times = generate_poisson_events(individual_rate, time_duration)
            num_events_list.append(num_events)
            event_times_list.append(event_times)
            inter_arrival_times_list.append(inter_arrival_times)

        if show_visualization:
            plot_sequential_poisson(num_events_list, event_times_list, inter_arrival_times_list, rate, time_duration)
        else:
            return num_events_list, event_times_list, inter_arrival_times_list

def matriz_tasas_generadora(tiempos, prob):
  """
  Función para obtener la matriz de tasas (R) y la matriz generadora (Q) a
  partir de los tiempos de permanenecia y las probabildiades de salto del proceso.

  Valores de entrada:
  - tiempos: lista con tiempos de permanencia de cada estado
  - prob: matriz de probabilidades de salto

  Valores de salida:
  - R: matriz de tasas
  - Q: matriz generadora
  """
  # Convertimos en arrays las lsitas de entrada
  tiempos = np.array(tiempos)
  prob = np.array(prob)
  # Tasas de permanencia
  tasas_permanencia = np.zeros(len(tiempos))
  # Calcula tasas de permanencia solo para tiempos distintos de cero
  mask = tiempos != 0
  tasas_permanencia[mask] = 1 / tiempos[mask]
  # Matriz de tasas
  R = np.round(tasas_permanencia[:, np.newaxis] * prob,2)
  # Matriz generadora
  Q = np.round(R - np.diag(tasas_permanencia),2)
  return R,Q

class CMTC:
    def __init__(self, Rmat): # Add estados as an argument
        """
        Inicializa la clase CMTC con la matriz de tasas Rmat y los estados.
        """
        self.Rmat = np.array(Rmat)

    def matriz_prob_salto(self, estados):
        """Obtiene la matriz de probabildiad de salto dividiendo cada elemento de cada fila de tasas por la suma de la fila."""
        Rmat = self.Rmat
        suma_filas = np.sum(Rmat, axis=1, keepdims=True)
        # Evitar la división por cero
        suma_filas[suma_filas == 0] = 1
        tasas_normalizadas = Rmat / suma_filas
        return pd.DataFrame(np.round(tasas_normalizadas, 6),index=estados, columns=estados)

    def matriz_prob_trans(self, estados, ts, cal=1):
        """
        Calcula la matriz de probabilidades de transición en el instante ts.
        """
        epsilon = 1e-05
        Rmat = self.Rmat
        ris = np.sum(Rmat, axis=1)
        rlimit = np.max(ris) if cal == 1 else np.sum(Rmat)
        hatP = Rmat / rlimit
        np.fill_diagonal(hatP, 1 - ris / rlimit)
        rts = rlimit * ts
        A = hatP
        c = np.exp(-rts)
        B = c * np.identity(Rmat.shape[0])
        suma = c
        k = 1
        while suma < (1 - epsilon):
            c = c * rts / k
            B = B + c * A
            A = A @ hatP
            suma = suma + c
            k = k + 1
        B = pd.DataFrame(np.round(B, 6), index=estados, columns=estados)
        return B

    def tiempos_ocupacion(self, estados, Ts, cal=1):
        """
        Calcula los tiempos de ocupación hasta el instante Ts.
        """
        epsilon = 1e-05
        Rmat = self.Rmat
        ris = np.sum(Rmat, axis=1)
        rlimit = np.max(ris) if cal == 1 else np.sum(Rmat)
        hatP = Rmat / rlimit
        np.fill_diagonal(hatP, 1 - ris / rlimit)
        k = 0
        A = hatP.copy()
        yek = math.exp(-rlimit * Ts)
        ygk = 1 - yek
        suma = ygk
        B = ygk * np.identity(Rmat.shape[0])
        cota = Ts - epsilon
        while suma / rlimit < cota:
            k += 1
            yek = yek * (rlimit * Ts) / k
            ygk = ygk - yek
            B = B + ygk * A
            A = A @ hatP
            suma = suma + ygk
        resultados = pd.DataFrame(np.round(B / rlimit, 6), index=estados, columns=estados)
        return resultados

    def distr_lim_general(self, estados):
        """
        Calcula la distribución límite.
        """
        Rmat = self.Rmat
        N = Rmat.shape[0]
        sumarows = np.diag(np.sum(Rmat, axis=1))
        A = Rmat.T - sumarows
        A[N - 1, :] = np.ones(N)
        b = np.zeros(N)
        b[N - 1] = 1
        p = np.linalg.solve(A, b)
        p = pd.DataFrame(np.round(p, 6), index=estados, columns=['p'])
        return p

    def tiempos_primer_paso(self, A, estados):
        """
        Calcula los tiempos de primer paso al conjunto de estados A.
        """
        Rmat = self.Rmat
        estados = [str(estado) for estado in estados]
        rts = np.diag(np.sum(Rmat, axis=1))
        Rmod = Rmat[~np.isin(np.arange(Rmat.shape[0]), A), :]
        Rmod = Rmod[:, ~np.isin(np.arange(Rmat.shape[1]), A)]
        rates = rts[~np.isin(np.arange(rts.shape[0]), A), :]
        rates = rates[:, ~np.isin(np.arange(rts.shape[1]), A)]
        lms = Rmod.shape[0]
        B = rates - Rmod
        CS = np.ones(lms)
        ps = np.linalg.solve(B, CS)
        resultados = {}
        for i, estado in enumerate(estados):
            if i not in A:
                resultados[f"estado {estado}"] = ps[i]
        return resultados


def system_MMs(tasa_arrival, tasa_service, tiempo, servers):
    """
    Simulador simpy del sistema M/M/s

    Parámetros de entrada:
    - tasa_arrival: Tasa de llegadas de clientes (clientes/ut)
    - tasa_service: Tasa de servicio de clientes (clientes/ut)
    - tiempo: Tiempo total de simulación (ut)
    - severs: Número de servidores

    Devuelve:
      Dataframe con el historial de simulación de cada cliente con columnas
        * ID_customer (identificador del cliente)
        * ID_server (identificador del servidor)
        * T_in (instante de tiempo en que el cliente accede al sistema)
        * T_init_service (instante de tiempo en que el cliente entra en servicio)
        * T_service (tiempo que el cliente tarda en ser servido)
        * T_out (instante de tiempo en que el cliente sale al sistema)
        * n_system (clientes en el sistema en el instante en que el cliente accede al sistema)
        * n_queue (clientes en la cola en el instante en que el cliente accede al sistema)
        * t_system (tiempo que el cliente pasa en el sistema)
        * t_queue (tiempo que el cliente pasa en la cola)
    """
    import simpy
    # 1. LISTA DE REGISTRO:
    # Aquí iremos guardando una tupla con los datos de cada cliente que termine su servicio.
    # Al final, esta lista se convertirá en el DataFrame.
    simula = []

    # 2. IDENTIFICADORES DE SERVIDORES:
    # Crea una lista simple [1, 2, ..., s] para ponerle una "etiqueta" al servidor.
    # Nota: Esto es puramente estético para el reporte, SimPy gestiona los recursos internamente.
    server_ids = list(range(1, servers + 1))

    # Clase para rerpesentar el comportamiento del cliente cuando accede al sistema
    class Servicio:
        # Constructor: Recibe el entorno de simulación, ID del cliente y el recurso (servidores)
        def __init__(self, env, id_cliente, servidor, server_id):
            self.env = env
            self.id_cliente = id_cliente
            self.servidor = servidor
            self.server_id = server_id

        # MËTODO PRINCIPAL DEL CLIENTE
        def servicio(self):
            # Paso 1: FOTO DE LLEGADA
            # Guardamos el tiempo exacto en que el cliente "aparece" en el sistema.
            t_arr = self.env.now

            # Paso 2: ESTADÍSTICAS DEL ESTADO ACTUAL
            # Antes de entrar, miramos cuánta gente hay ya.
            # servidor.queue: Lista de procesos esperando.
            # servidor.count: Número de servidores ocupados actualmente.
            cola = len(self.servidor.queue)
            servidos = self.servidor.count
            sistema = cola + servidos

            # Paso 3: SOLICITUD DE RECURSO (Entrar a la cola/servidor)
            # 'self.servidor.request()' intenta ocupar un servidor.
            # Si hay sitio (count < servers), entra inmediatamente.
            # Si NO hay sitio, el proceso se congela aquí (yield) hasta que se libere uno.
            with self.servidor.request() as solicitud:
                yield solicitud  # <--- Aquí ocurre la espera en cola si es necesario.

                # --- A PARTIR DE AQUÍ EL CLIENTE YA ESTÁ SIENDO ATENDIDO ---

                # Asignamos el ID del servidor (lógica definida en la llamada).
                id_servidor = self.server_id

                # Paso 4: INICIO DE SERVICIO
                # Guardamos el tiempo exacto en que dejó de esperar y empezó a ser atendido.
                t_ini = self.env.now

                # Paso 5: DURACIÓN DEL SERVICIO
                # Calculamos cuánto tardará, basado en una distribución exponencial.
                t_service = random.expovariate(tasa_service)

                # Paso 6: PROCESO DE ATENCIÓN
                # 'yield env.timeout(t_service)' le dice al simulador:
                # "Mantén este servidor ocupado durante 't_service' unidades de tiempo".
                yield env.timeout(t_service)

                # Paso 7: SALIDA
                # El cliente ha terminado. Guardamos el tiempo final.
                t_out = self.env.now

                # Paso 8: GUARDADO DE DATOS
                # Calculamos tiempos de estancia (salida - llegada) y espera (inicio - llegada).
                # Todo se mete en la lista 'simula'.
                simula.append((self.id_cliente,
                               self.server_id,
                               t_arr,
                               t_ini,
                               t_service,
                               t_out,
                               t_out-t_arr,     # Tiempo total en sistema (W)
                               t_ini-t_arr,     # Tiempo en cola (Wq)
                               sistema,         # N total al llegar
                               cola))           # N cola al llegar

    # Función para generar el proceso de llegada de los clientes (Movida fuera de la clase Servicio)
    def llegada_clientes(env, tasa_arrival):
        id_cliente = 1  # Contador para dar ID único a cada cliente

        while True:
          # Paso A: TIEMPO ENTRE LLEGADAS
          # Calculamos cuánto tiempo pasará hasta que llegue el siguiente cliente.
          tiempo_entre_llegadas = random.expovariate(tasa_arrival)

          # Paso B: ESPERA HASTA LA LLEGADA
          # Detiene la creación de clientes durante ese tiempo aleatorio.
          yield env.timeout(tiempo_entre_llegadas)

          # Paso C: LÓGICA DE ASIGNACIÓN DE SERVIDOR (Rotativo)
          # Intenta asignar un ID de servidor 1, 2, ... s, 1, 2...
          # Nota: Esto es una etiqueta visual, SimPy asignará el primer recurso libre real.
          # Using modulo operator for server_id assignment to cycle through available servers
          current_server_id = server_ids[(id_cliente - 1) % servers]

          # Paso D: CREACIÓN DEL OBJETO CLIENTE
          # Instanciamos la clase Servicio con los datos actuales.
          cliente = Servicio(env, id_cliente, servidor, current_server_id)

          # Contadores para la siguiente vuelta
          id_cliente += 1

          # Paso E: INICIO DEL PROCESO DEL CLIENTE
          # Le decimos al entorno: "Arranca el método servicio() de este nuevo cliente".
          # Esto corre en paralelo (async) con el resto de la simulación.
          env.process(cliente.servicio())

    # 1. CREAR ENTORNO
    # El cerebro de la simulación que maneja el reloj (env.now).
    env = simpy.Environment()

    # 2. CREAR RECURSO (SERVIDORES)
    # Definimos que hay una capacidad limitada ('servers').
    # Si llegan más de 'servers' clientes, SimPy gestiona la cola automáticamente.
    servidor = simpy.Resource(env, capacity = servers)

    # 3. ACTIVAR EL GENERADOR
    # Iniciamos el proceso que crea clientes. Sin esto, la simulación estaría vacía.
    env.process(llegada_clientes(env, tasa_arrival))

    # 4. EJECUTAR
    # Corre la simulación hasta que el reloj interno llegue a 'tiempo'.
    env.run(until = tiempo)

    # 5. PROCESAR RESULTADOS
    # Convertimos la lista de tuplas en un DataFrame legible.
    df = pd.DataFrame(simula, columns=['ID_customer', 'ID_server', 'T_in', 'T_init_service', 'T_service', 'T_out', 'T_system', 'T_queue','N_system', 'N_queue'])

    # Ordenamos por ID de cliente para que la tabla se vea ordenada 1, 2, 3...
    df = df.sort_values(by = ["ID_customer"])

    return df     




import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import seaborn as sns
import numpy as np
from matplotlib.lines import Line2D
import warnings
# Filtramos advertencias menores por si acaso alguna versión diferente de librería protesta
warnings.filterwarnings("ignore")

def plot_historial_MMs(historial):
  """
  Funnción para representar el historial de simulación del sistema M/M/s

  Parámetros de entrada:
  - historial: Dataframe

  Devuelve:
    Gráficas del historial de simulación
  """
  # 1. Tamaño de la figura
  fig = plt.figure(figsize=(22, 12)) 
  
  # --- ESTRUCTURA DE LA REJILLA (GRID) ---
  gs_main = gridspec.GridSpec(1, 2, figure=fig, width_ratios=[1, 2.2], wspace=0.15)
  gs_right = gridspec.GridSpecFromSubplotSpec(2, 1, subplot_spec=gs_main[1], 
                                              height_ratios=[1, 1], hspace=0.4)
  gs_right_top = gridspec.GridSpecFromSubplotSpec(1, 3, subplot_spec=gs_right[0], wspace=0.3)
  gs_right_bot = gridspec.GridSpecFromSubplotSpec(1, 2, subplot_spec=gs_right[1], wspace=0.3)

  # --- CREACIÓN DE LOS EJES ---
  ax_gantt_cli = fig.add_subplot(gs_main[0])          
  ax_tservice  = fig.add_subplot(gs_right_top[0])     
  ax_compare   = fig.add_subplot(gs_right_top[1])     
  ax_gantt_srv = fig.add_subplot(gs_right_top[2])     
  ax_nsystem   = fig.add_subplot(gs_right_bot[0])     
  ax_nqueue    = fig.add_subplot(gs_right_bot[1])     

  # ==========================================================================
  # 1. GANTT CLIENTES (IZQUIERDA)
  # ==========================================================================
  ax_gantt_cli.hlines(y=historial['ID_customer'], 
             xmin=historial['T_in'], 
             xmax=historial['T_out'], 
             color='limegreen', linewidth=3, label='Permanencia en el sistema')
  ax_gantt_cli.scatter(x=historial['T_init_service'], 
              y=historial['ID_customer'], 
              color='red', s=50, zorder=3, marker='|', linewidth=2, label='Inicio Servicio')
  ax_gantt_cli.set_xlabel('Tiempo de simulación')
  ax_gantt_cli.set_ylabel('ID Cliente')
  ax_gantt_cli.set_title('Cronograma de Clientes (Gantt)')
  ax_gantt_cli.legend(loc='upper left', fontsize='small')
  ax_gantt_cli.grid(True, alpha=0.3, axis='x')

  # ==========================================================================
  # 2. DISTRIBUCIÓN T. SERVICIO (DERECHA ARRIBA 1)
  # ==========================================================================
  # CORRECCIÓN: Se añade hue=ID_server y legend=False para evitar FutureWarning
  sns.boxplot(x='ID_server', y='T_service', hue='ID_server', data=historial, 
              ax=ax_tservice, palette='Blues', legend=False)
  ax_tservice.set_xlabel('Servidor')
  ax_tservice.set_ylabel('Tiempo')
  ax_tservice.set_title('Distribución T. Servicio')

  # ==========================================================================
  # 3. COMPARATIVA DE TIEMPOS (DERECHA ARRIBA 2)
  # ==========================================================================
  data_cajas = historial[['T_system', 'T_queue', 'T_service']].copy()
  data_cajas.columns = ['Sistema', 'Cola', 'Servicio']
  sns.boxplot(data=data_cajas, orient='h', ax=ax_compare, palette="Set2")
  ax_compare.set_xlabel('Tiempo')
  ax_compare.set_title('Comparativa Tiempos')
  ax_compare.grid(True, alpha=0.3, axis='x')

  # ==========================================================================
  # 4. GANTT SERVIDORES (DERECHA ARRIBA 3)
  # ==========================================================================
  max_tiempo = historial['T_out'].max()
  unique_servers = sorted(historial['ID_server'].unique())
  # A) Barra de DISPONIBILIDAD
  for srv in unique_servers:
      ax_gantt_srv.hlines(y=srv, xmin=0, xmax=max_tiempo, 
                          color='forestgreen', linewidth=8, alpha=0.7)
  # B) Barras de OCUPACIÓN
  ax_gantt_srv.hlines(y=historial['ID_server'], 
                      xmin=historial['T_init_service'], 
                      xmax=historial['T_out'], 
                      color='red', linewidth=8, label='Ocupado')
  ax_gantt_srv.set_xlabel('Tiempo')
  ax_gantt_srv.set_ylabel('Servidor')
  ax_gantt_srv.set_title('Ocupación Servidores')
  ax_gantt_srv.set_yticks(unique_servers)
  ax_gantt_srv.grid(True, alpha=0.3, axis='x')
  custom_lines = [Line2D([0], [0], color='forestgreen', lw=4, alpha=0.7),
                  Line2D([0], [0], color='red', lw=4)]

  # ==========================================================================
  # 5. CLIENTES EN SISTEMA (DERECHA ABAJO 1)
  # ==========================================================================
  sns.countplot(y='N_system', data=historial, stat='percent', ax=ax_nsystem, 
                color="skyblue") 
  ax_nsystem.set_ylabel('Clientes en el sistema')
  ax_nsystem.set_xlabel('% Frecuencia')
  ax_nsystem.set_title('Estado del Sistema al llegar nuevo cliente')
  if not historial.empty:
      max_sys = int(max(historial['N_system']))
      ax_nsystem.set_yticks(np.arange(0, max_sys + 1, 1))
      for container in ax_nsystem.containers:
          ax_nsystem.bar_label(container, fmt='%.1f%%', padding=3, fontsize=9)

  # ==========================================================================
  # 6. CLIENTES EN COLA (DERECHA ABAJO 2)
  # ==========================================================================
  sns.countplot(y='N_queue', data=historial, stat='percent', ax=ax_nqueue, 
                color="salmon")
  ax_nqueue.set_ylabel('Clientes en la cola')
  ax_nqueue.set_xlabel('% Frecuencia')
  ax_nqueue.set_title('Estado de la Cola al llegar nuevo cliente')
  if not historial.empty:
      max_queue = int(max(historial['N_queue']))
      ax_nqueue.set_yticks(np.arange(0, max_queue + 1, 1))
      for container in ax_nqueue.containers:
          ax_nqueue.bar_label(container, fmt='%.1f%%', padding=3, fontsize=9)

  plt.show()



def get_stats_MMs(historial, servidores, tiempo):
    """
    Función para obtener medidas de eficiencia del sistema

    Argumentos:
     historial: Dataframe con el historial de simulación de cada
     servidores: Número de servidores
     tiempo: Tiempo de simulación

    Devuelve:
     Dataframe con las medidas de eficiencia del sistema
      - 'Clientes', Clientes que han accedido al sistema
      - 'L', Número medio de clienets en el sistema
      - 'Lq', Número medio de clientes en la cola
      - 'W', Tiempo medio de permanencia en el sistema
      - 'Wq', Tiemo medio de permanencia en la cola
      - '% tq', porcentaje de tiempo que los clientes pasan en cola respecto del tiempo total en el sistema
      - '% so', porcentaje de ocupación de los servidores
      - '% Ocupación ..', porcentaje de ocupación de cada servidor.    
    """
    # 1. Medidas Básicas
    clientes = historial.shape[0]
    
    # Prevenimos errores si el historial está vacío
    if clientes == 0:
        return pd.DataFrame({'Mensaje': ['Sin clientes procesados']}).T

    L = historial['N_system'].mean()  # Promedio clientes en sistema
    Lq = historial['N_queue'].mean()  # Promedio clientes en cola
    W = historial['T_system'].mean()  # Tiempo promedio en sistema
    Wq = historial['T_queue'].mean()  # Tiempo promedio en cola
    
    # % Tiempo en cola respecto al sistema
    perc_tq = (Wq / W * 100) if W > 0 else 0

    # ---------------------------------------------------------------
    # 2. CÁLCULO DE OCUPACIÓN GLOBAL (% so)
    # ---------------------------------------------------------------
    # Este cálculo es INDEPENDIENTE de los IDs de los servidores.
    # Suma todos los tiempos de servicio trabajados por cualquier servidor.
    total_service_time = historial['T_service'].sum()
    # Capacidad total disponible = (número servidores) * (tiempo simulación)
    capacity_total = servidores * tiempo
    perc_so = (total_service_time / capacity_total) * 100

    # ---------------------------------------------------------------
    # 3. OCUPACIÓN POR CADA SERVIDOR (S1, S2...) - CORREGIDO
    # ---------------------------------------------------------------
    # Agrupamos por ID_server. 
    usage_per_server = historial.groupby('ID_server')['T_service'].sum()
    dict_stats = {
        'Clientes': round(clientes, 0),
        'L': round(L, 2),
        'Lq': round(Lq, 2),
        'W': round(W, 2),
        'Wq': round(Wq, 2),
        '% tq (Cola/Total)': round(perc_tq, 2),
        '% so (Ocupación Global)': round(perc_so, 2)
    }

    for s in range(1, servidores + 1):
        # Buscamos el ID 's' (1, 2, 3...). Si no existe, devuelve 0.
        t_trabajado = usage_per_server.get(s, 0) 
        ocupacion_individual = (t_trabajado / tiempo) * 100
        # Guardamos con la etiqueta correcta S1, S2, S3...
        dict_stats[f'% Ocupación S{s}'] = round(ocupacion_individual, 2)

    # 4. Crear DataFrame final con Index "Sistema"
    resumen = pd.DataFrame(dict_stats, index=['Sistema'])
    
    return resumen

def MC_MMs(tasa_arrival, tasa_service, tiempo, servers, nsims):
    # 1. Contenedor temporal para los resultados
    # Usamos una lista en lugar de un DataFrame pre-definido para flexibilidad
    resultados_acumulados = []
    
    # Semilla para reproducibilidad
    random.seed(124) 

    for i in range(nsims):
        # A. Ejecutar simulación
        historial = system_MMs(tasa_arrival, tasa_service, tiempo, servers)
        # B. Obtener estadísticas con la nueva función
        # Esto devuelve un DataFrame de 1 fila con columnas dinámicas (S1, S2...)
        stats_df = get_stats_MMs(historial, servers, tiempo)
        # C. Guardar la fila de resultados
        # Convertimos la fila a diccionario y la añadimos a la lista
        resultados_acumulados.append(stats_df.iloc[0].to_dict())

    # 2. Crear DataFrame con todas las simulaciones
    # Pandas detecta automáticamente los nombres de las columnas (incluyendo S1, S2...)
    eficiencia = pd.DataFrame(resultados_acumulados)

    # 3. Análisis Monte-Carlo
    analisis_MC = pd.DataFrame(columns=['Media', 'IC0.025', 'IC0.975'])
    nombres_metricas = eficiencia.columns

    for metrica in nombres_metricas:
        # Aplicamos la función MC_estim a cada columna detectada
        # Asumimos que MC_estim devuelve [Media, Límite Inferior, Límite Superior]
        analisis_MC.loc[metrica, ['Media', 'IC0.025', 'IC0.975']] = MC_estim(eficiencia[metrica])

    return analisis_MC

def system_MMinf(tasa_arrival, tasa_service, tiempo):
    """
    Simulador simpy del sistema M/M/infinito

    Parámetros de entrada:
    - tasa_arrival: Tasa de llegadas de clientes (clientes/ut)
    - tasa_service: Tasa de servicio de clientes (clientes/ut)
    - tiempo: Tiempo total de simulación (ut)

    Devuelve:
      Dataframe con el historial de simulación de cada cliente con columnas
        * ID_customer (identificador del cliente)
        * T_in (instante de tiempo en que el cliente accede al sistema)
        * T_out (instante de tiempo en que el cliente sale al sistema)
        * n_system (clientes en el sistema en el instante en que el cliente accede al sistema)
        * t_system (tiempo que el cliente pasa en el sistema)
    """
    import simpy
    # Lista para guardar los datos
    simula = []

    class Servicio:
        def __init__(self, env, id_cliente, servidor):
            self.env = env
            self.id_cliente = id_cliente
            self.servidor = servidor

        def servicio(self):
            # 1. LLEGADA
            t_arr = self.env.now
            # N_system: Clientes dentro justo antes de que este entre
            n_system = self.servidor.count
            # 2. ENTRADA (Sin espera, capacidad infinita)
            with self.servidor.request() as solicitud:
                yield solicitud
                # Generamos duración
                t_service = random.expovariate(tasa_service)
                # 3. SERVICIO
                yield self.env.timeout(t_service)
                # 4. SALIDA
                t_out = self.env.now
                # 5. REGISTRO
                # Se guarda al terminar, por lo que el orden natural sería por T_out
                simula.append((
                    self.id_cliente,
                    t_arr,
                    t_out,
                    t_out - t_arr,  # T_system
                    n_system
                ))

    def llegada_clientes(env, tasa_arrival, servidor):
        id_cliente = 1
        while True:
            yield env.timeout(random.expovariate(tasa_arrival))
            cliente = Servicio(env, id_cliente, servidor)
            env.process(cliente.servicio())
            id_cliente += 1

    # --- EJECUCIÓN ---
    env = simpy.Environment()
    servidor = simpy.Resource(env, capacity=float('inf')) # Infinitos servidores
    env.process(llegada_clientes(env, tasa_arrival, servidor))
    env.run(until=tiempo)
    # --- DATAFRAME ---
    df = pd.DataFrame(simula, columns=['ID_customer', 'T_in', 'T_out', 'T_system', 'N_system'])
    df = df.sort_values(by='T_in').reset_index(drop=True)
    
    return df

def plot_historial_MMinf(historial):
    """
    Visualización gráfica específica para M/M/inf:
    1. Cronograma de estancias (Gantt).
    2. Boxplot de Tiempos de Sistema (Estancia).
    3. Frecuencia de estados del sistema (N) con porcentajes.
    """
    
    # Configuración del lienzo
    fig = plt.figure(figsize=(10, 8))
    gs = fig.add_gridspec(2, 2)

    # Definición de los ejes
    ax1 = fig.add_subplot(gs[0, :]) # Fila superior completa
    ax2 = fig.add_subplot(gs[1, 0]) # Abajo Izquierda
    ax3 = fig.add_subplot(gs[1, 1]) # Abajo Derecha

    # ---------------------------------------------------------
    # GRÁFICO 1: Cronograma (Gantt)
    # ---------------------------------------------------------
    ax1.hlines(y=historial['ID_customer'], 
               xmin=historial['T_in'], 
               xmax=historial['T_out'], 
               color='green', alpha=0.6, linewidth=3, label='En Servicio')
    
    ax1.set_title('Cronograma de Clientes - Sistema $M/M/\infty$')
    ax1.set_xlabel('Tiempo de Simulación')
    ax1.set_ylabel('ID Cliente')
    ax1.grid(True, linestyle='--', alpha=0.5)
    
    if not historial.empty:
        ax1.set_ylim(0, historial['ID_customer'].max() + 1)
        ax1.set_xlim(0, historial['T_out'].max() * 1.05)

    # ---------------------------------------------------------
    # GRÁFICO 2: Histograma (T_system) 
    # ---------------------------------------------------------
    # Usamos un histograma para ver la forma de la distribución
    # 'bins='auto'' deja que matplotlib decida el ancho óptimo de las barras
    ax2.hist(historial['T_system'], bins='auto', color='steelblue', edgecolor='steelblue', alpha=0.7)
    
    ax2.set_title('Histograma de Tiempos en el Sistema ($W$)')
    ax2.set_xlabel('Tiempo (ut)')
    ax2.set_ylabel('Frecuencia')
    ax2.grid(axis='y', linestyle=':', alpha=0.5)

    # ---------------------------------------------------------
    # GRAFICO 3: Frecuencias de N_system 
    # ---------------------------------------------------------
    # 1. Obtenemos las frecuencias absolutas (Conteo puro)
    conteo_estados = historial['N_system'].value_counts().sort_index()
    total_obs = conteo_estados.sum()
    
    # 2. Dibujamos las barras usando el conteo
    barras = ax3.bar(conteo_estados.index, conteo_estados.values, 
                     color='orange', alpha=0.7, edgecolor='black')
    
    ax3.set_title('Número de clientes en el sistema al llegar un nuevo cliente')
    ax3.set_xlabel('Clientes')
    ax3.set_ylabel('Porcentaje')
    
    # 3. Añadimos los porcentajes encima de cada barra
    # Aumentamos un poco el límite Y para que quepa el texto
    if not conteo_estados.empty:
        ax3.set_ylim(0, max(conteo_estados.values) * 1.15)
        
        for barra in barras:
            height = barra.get_height()
            percentage = (height / total_obs) * 100
            ax3.text(barra.get_x() + barra.get_width() / 2, height, 
                     f'{percentage:.1f}%', 
                     ha='center', va='bottom', fontsize=9, color='black')

    # Ajustamos eje X para mostrar enteros
    if len(conteo_estados) < 20:
        ax3.set_xticks(conteo_estados.index)
        
    ax3.grid(axis='y', linestyle=':', alpha=0.5)

    plt.tight_layout()
    plt.show()


def get_stats_MMinf(historial, tiempo):
    """
    Función para obtener medidas de eficiencia del sistema M/M/inf.
    
    Argumentos:
     historial: Dataframe con columnas 'T_in', 'T_out', 'T_system', etc.
     tiempo: Tiempo total de simulación (ut)
    
    Devuelve:
     Clientes: clientes que han finalizado el servicio 
     L: promedio de clientes en el sistema
     W: promedio de tiempo en el sistema
     perc_inactivo: porcentaje de tiempo que el sistema no tiene clientes
    """
    # 1. Medidas Básicas
    clientes = historial.shape[0]
    
    if clientes == 0:
        return pd.DataFrame({'Mensaje': ['Sin clientes procesados']}).T

    L = historial['N_system'].mean()   # Promedio clientes (simulado)
    W = historial['T_system'].mean()   # Tiempo promedio en sistema

    # 2. CÁLCULO DE TIEMPO VACÍO (% Inactivo)
    # El sistema está ocupado si hay AL MENOS una persona.
    # Como los clientes se solapan, unimos los intervalos [T_in, T_out].
    
    # a) Ordenamos por llegada
    df_sorted = historial.sort_values('T_in')
    # b) Algoritmo de fusión de intervalos (Merge Intervals)
    busy_intervals = []
    # Iteramos sobre cada cliente
    for _, row in df_sorted.iterrows():
        start, end = row['T_in'], row['T_out']
        
        if not busy_intervals:
            # Primer intervalo
            busy_intervals.append([start, end])
        else:
            # Comparamos con el último intervalo guardado
            last_start, last_end = busy_intervals[-1]
            
            if start < last_end:
                # Si hay solape, extendemos el final si es necesario
                busy_intervals[-1][1] = max(last_end, end)
            else:
                # No hay solape (hubo un hueco), añadimos nuevo intervalo
                busy_intervals.append([start, end])
    
    # c) Sumamos la duración de los intervalos de ocupación
    tiempo_ocupado_total = sum(end - start for start, end in busy_intervals)
    # d) Calculamos el tiempo vacío
    tiempo_vacio = tiempo - tiempo_ocupado_total
    # Aseguramos que no sea negativo (por si la simulación se pasó un poco del límite)
    tiempo_vacio = max(0, tiempo_vacio)
    
    perc_inactivo = (tiempo_vacio / tiempo) * 100

    # ---------------------------------------------------------------
    # 3. CREACIÓN DEL DATAFRAME
    # ---------------------------------------------------------------
    dict_stats = {
        'Clientes': round(clientes, 0),
        'L': round(L, 2),
        'W': round(W, 2),
        '% Inactivo (Vacío)': round(perc_inactivo, 2)
    }
    
    resumen = pd.DataFrame(dict_stats, index=['Sistema'])
    
    return resumen

def MC_MMinf(tasa_arrival, tasa_service, tiempo, nsims):
  # Conjunto de simulaciones
  eficiencia = pd.DataFrame(columns=['Clientes', 'L', 'W', '% Inactivo'])
  random.seed(124)
  for i in range(nsims):
    historial = system_MMinf(tasa_arrival, tasa_service, tiempo)
    eficiencia.loc[i,:] = get_stats_MMinf(historial, tiempo).iloc[0,].tolist()

  # Análisis Monte-Carlo
  analisis_MC = pd.DataFrame(columns=['Media', 'IC0.025', 'IC0.975'])
  nombres = eficiencia.columns
  for i in range(len(nombres)):
      analisis_MC.loc[i, ['Media', 'IC0.025', 'IC0.975']] = MC_estim(eficiencia[nombres[i]])
  analisis_MC.index = nombres
  return analisis_MC


def system_MMsK(tasa_arrival, tasa_service, tiempo, servers, K):
    """
    Simulador simpy del sistema M/M/s/K (Capacidad finita)

    Parámetros:
    - tasa_arrival: Tasa de llegadas lambda
    - tasa_service: Tasa de servicio mu
    - tiempo: Tiempo de simulación
    - servers: Número de servidores (s)
    - K: Capacidad del sistema (s + cola máxima)
    
    Devuelve: DataFrame con historial
    """
    import simpy
    # Lista para guardar registros
    simula = []
    
    # Lista auxiliar para IDs de servidores (ej: [1, 2, 3])
    server_ids_list = list(range(1, servers + 1))

    class Servicio:
        def __init__(self, env, id_cliente, servers, servidor, server_id, K):
            self.env = env
            self.id_cliente = id_cliente
            self.servidores = servers
            self.servidor = servidor
            self.server_id = server_id
            self.K = K

        def servicio(self):
            t_arr = self.env.now
            
            # Condición de bloqueo: ¿Hay sitio en el sistema?
            # Capacidad ocupada = gente en cola + gente siendo atendida
            ocupacion_actual = len(self.servidor.queue) + self.servidor.count
            
            if ocupacion_actual < self.K:
                # --- CASO ACEPTADO ---
                aceptado = 1
                
                # Estadísticas Pre-Servicio
                cola = len(self.servidor.queue)
                servidos = self.servidor.count
                sistema = cola + servidos
                
                with self.servidor.request() as solicitud:
                    yield solicitud # Espera en cola si es necesario
                    
                    # --- INICIO SERVICIO ---
                    t_ini = self.env.now
                    t_service = random.expovariate(tasa_service)
                    
                    yield self.env.timeout(t_service)
                    
                    # --- FIN SERVICIO ---
                    t_out = self.env.now
                    
                    # Guardamos resultados (AÑADIDO self.id_cliente AL PRINCIPIO)
                    simula.append((
                        self.id_cliente,    # <--- NUEVO CAMPO
                        self.server_id,
                        t_arr,
                        t_ini,
                        t_service,
                        t_out,
                        t_out - t_arr,      # T_system
                        t_ini - t_arr,      # T_queue
                        sistema,
                        cola,
                        aceptado
                    ))
            else:
                # --- CASO RECHAZADO (SISTEMA LLENO) ---
                aceptado = 0
                cola = self.K - self.servidores # La cola está llena
                sistema = self.K                # El sistema está lleno
                t_out = t_arr                   # Sale inmediatamente (rebotado)
                
                # Guardamos resultados (AÑADIDO self.id_cliente)
                simula.append((
                    self.id_cliente,    # <--- NUEVO CAMPO
                    0,                  # ID Server 0 indica rechazo/sin servicio
                    t_arr,
                    np.nan,             # No hubo servicio
                    np.nan,
                    np.nan,             # No salió normalmente
                    np.nan,
                    np.nan,
                    sistema,
                    cola,
                    aceptado
                ))

    def llegada_clientes(env, tasa_arrival):
        id_cliente = 0
        while True:
            # Generar siguiente llegada
            tiempo_entre_llegadas = random.expovariate(tasa_arrival)
            yield env.timeout(tiempo_entre_llegadas)
            
            id_cliente += 1
            
            # Asignación rotativa de ID visual del servidor
            # (Nota: SimPy asigna el recurso real, esto es solo etiqueta)
            current_server_id = server_ids_list[(id_cliente - 1) % servers]
            
            cliente = Servicio(env, id_cliente, servers, servidor, current_server_id, K)
            env.process(cliente.servicio())

    # --- EJECUCIÓN ---
    env = simpy.Environment()
    servidor = simpy.Resource(env, capacity=servers)
    
    env.process(llegada_clientes(env, tasa_arrival))
    env.run(until=tiempo)

    # --- PROCESADO ---
    # Definimos columnas incluyendo la nueva ID_customer
    cols = ['ID_customer', 'ID_server', 'T_in', 'T_init_service', 
            'T_service', 'T_out', 'T_system', 'T_queue',
            'N_system', 'N_queue', 'Accepted']
            
    df = pd.DataFrame(simula, columns=cols)
    
    # Ordenar y limpiar
    df = df.sort_values(by=["T_in"]).reset_index(drop=True)

    # Lógica de recorte final (conservada de tu código original)
    # Nota: Filtramos NaNs en T_out para que idxmax no falle con los rechazados
    if not df['T_out'].dropna().empty:
        indice_max_tout = df['T_out'].idxmax()
        # Aseguramos no pasarnos del índice
        corte = min(indice_max_tout + 2, len(df))
        df = df.iloc[:corte, :]

    return df
